function KeyGen(n, k, t, r):
  // n, k, t, and r are system parameters
  // n = code length
  // k = message dimension
  // t = error correction capability
  // r = dimension of random matrices

  // 1. Select a linear code with an efficient decoding algorithm.
  // Gs is a k x n generator matrix for this secret code.
  private_key_Gs = select_generator_matrix()

  // 2. Select random, non-singular matrices to scramble the code.
  // S is a random k x k non-singular matrix.
  // P1 is a random n x n permutation matrix.
  // A0, A1, ... An-1 are random (r+1) x (r+1) non-singular matrices.
  // A is a block diagonal matrix of these Ai matrices.
  S = random_non_singular_matrix(k)
  P1 = random_permutation_matrix(n)
  A = block_diagonal_matrix_of_random_matrices()

  // 3. Create G1 by inserting r random columns into Gs after each column
  // then permuting the columns with P1.
  G1 = randomize_and_permute_columns(Gs, r, P1)
  
  // 4. Create the public key by scrambling G1.
  // P2 is another random permutation matrix.
  P2 = random_permutation_matrix(n * (r + 1))
  public_key = S * G1 * A * P2
  
  private_key = (S, Gs, P1, P2, A)
  
  return (public_key, private_key)

function Encrypt(public_key, message):
  // public_key = G
  // message is a row vector m of length k
  
  // 1. Choose a random error vector e.
  // The error vector e has length n * (r + 1) and a small Hamming weight (at most t).
  error_vector = random_vector_with_small_weight(t)

  // 2. Compute the ciphertext by adding the encoded message and the error.
  // c = m * G + e (mod q)
  ciphertext = (message * public_key) + error_vector
  
  return ciphertext

function Decrypt(private_key, ciphertext):
  // private_key = (S, Gs, P1, P2, A)
  // ciphertext = c
  
  // 1. Reverse the final scrambling steps
  // This step removes the effect of the P2 and A matrices.
  // We get a vector that is the original message combined with a residual error.
  temp_vector_1 = ciphertext * inverse(P2) * inverse(A)

  // 2. Extract a new error vector and reverse the first permutation
  // This step extracts a new vector (c0) and removes the effect of P1.
  temp_vector_2 = extract_and_inverse_permute(temp_vector_1, P1)
  
  // 3. Use the secret decoding algorithm
  // This step removes the effect of the error vector and Gs.
  // The result is the message multiplied by the secret matrix S.
  decoded_vector = decode_with_secret_algorithm(temp_vector_2, Gs)
  
  // 4. Recover the original message
  // This final step removes the effect of the secret matrix S.
  decrypted_message = decoded_vector * inverse(S)
  
  return decrypted_message